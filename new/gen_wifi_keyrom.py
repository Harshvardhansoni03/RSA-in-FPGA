#!/usr/bin/env python3
"""
gen_wifi_keyrom.py

Reads a WiFi profile text file produced by:
  netsh wlan show profile name="POCO M4 PRO" key=clear > WiFi_Profile_Info.txt

Finds the "Key Content" line, packs the password into a 64-bit integer
(as 8 bytes, big-endian: first char -> most-significant byte), and
generates a Verilog module wifi_key_rom.v containing the constant.

Usage:
  python gen_wifi_keyrom.py
  python gen_wifi_keyrom.py --input "D:/path/WiFi_Profile_Info.txt" --output "D:/path/wifi_key_rom.v"
"""

import argparse
import re
from pathlib import Path
import sys

def extract_key_content(text):
    """
    Try to find the password line in the netsh output.
    Matches lines like:
       Key Content            : MyPassword123
    Case-insensitive.
    Returns the password string (stripped) or None if not found.
    """
    # Common pattern
    m = re.search(r'Key Content\s*:\s*(.+)', text, flags=re.IGNORECASE)
    if m:
        return m.group(1).strip()
    # Try alternate patterns (some locales or outputs may differ)
    # Look for lines that contain 'Key' and look like a password following ':'
    # This is a fallback and may produce false positives.
    for line in text.splitlines():
        if ':' in line and 'key' in line.lower():
            parts = line.split(':', 1)
            candidate = parts[1].strip()
            if candidate:
                return candidate
    return None

def pack_password_to_64bit(password_str, encoding='utf-8'):
    """
    Encode password_str into bytes (UTF-8 by default).
    If bytes length > 8 -> truncate to first 8 bytes (with a warning).
    If bytes length < 8 -> pad with 0x00 bytes on the right.
    Return hex string of 8 bytes (16 hex chars), big-endian (first byte -> MSB).
    """
    b = password_str.encode(encoding, errors='replace')  # replace invalid chars
    if len(b) > 8:
        print(f"WARNING: password bytes length {len(b)} > 8 -> truncating to first 8 bytes.")
        b = b[:8]
    elif len(b) < 8:
        pad_len = 8 - len(b)
        print(f"NOTE: password bytes length {len(b)} < 8 -> padding with {pad_len} zero byte(s).")
        b = b + b'\x00' * pad_len
    # Build hex string (MSB first)
    hex_str = ''.join(f'{byte:02X}' for byte in b)
    return hex_str, b

def generate_verilog(m_hex, module_name='wifi_key_rom', output_path=None, comment_extra=''):
    """
    Generate a simple Verilog module containing a localparam with the 64-bit value.
    m_hex should be a 16-character hex string (without 0x), e.g. '4133246239405821'
    """
    if len(m_hex) != 16:
        raise ValueError("m_hex must be 16 hex characters (8 bytes / 64 bits).")
    verilog = f"""// Generated by gen_wifi_keyrom.py
// Packed Wi-Fi password (64-bit) - big-endian (first character -> MSB)
{comment_extra}
module {module_name} (
    output wire [63:0] m_out
);

    // 64-bit packed constant
    localparam [63:0] M_CONST = 64'h{m_hex};
    assign m_out = M_CONST;

endmodule
"""
    if output_path:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(verilog)
    return verilog

def main():
    p = argparse.ArgumentParser(description="Generate wifi_key_rom.v from netsh output txt")
    default_input = Path(r"D:\vivado_projects\WiFi_key_encrypt\WiFi_key_encrypt.srcs\sources_1\new\WiFi_Profile_Info.txt")
    default_output = default_input.with_name("wifi_key_rom.v")
    p.add_argument('--input', '-i', default=str(default_input),
                   help=f'Input netsh txt file (default: {default_input})')
    p.add_argument('--output', '-o', default=str(default_output),
                   help=f'Output Verilog file (default: {default_output})')
    p.add_argument('--module', '-m', default='wifi_key_rom', help='Verilog module name')
    p.add_argument('--encoding', '-e', default='utf-8', help='Encoding to use for password bytes (default utf-8)')
    args = p.parse_args()

    input_path = Path(args.input)
    output_path = Path(args.output)

    if not input_path.exists():
        print(f"ERROR: Input file not found: {input_path}")
        sys.exit(1)

    text = input_path.read_text(encoding='utf-8', errors='ignore')
    password = extract_key_content(text)
    if password is None:
        print("ERROR: Could not find 'Key Content' line in the file.")
        print("Tip: open the file and look for the line containing the password (Key Content : <password>)")
        # Optionally print a few lines around likely places
        lines = text.splitlines()
        snippet = '\n'.join(lines[:60])
        print("\n--- start of file preview (first 60 lines) ---")
        print(snippet)
        print("--- end of preview ---\n")
        sys.exit(1)

    print(f"Found password (raw): '{password}'")

    m_hex, packed_bytes = pack_password_to_64bit(password, encoding=args.encoding)
    print(f"Packed 8 bytes (hex): {m_hex}")
    print(f"Packed bytes (hex pairs): {' '.join(f'{b:02X}' for b in packed_bytes)}")

    comment = f"// Source file: {input_path}\n// Extracted password (raw): {password}"
    verilog_text = generate_verilog(m_hex, module_name=args.module, output_path=str(output_path), comment_extra=comment)

    print(f"\nWrote Verilog module to: {output_path}")
    print("\nExample module content (first 30 lines):\n")
    print('\n'.join(verilog_text.splitlines()[:30]))
    print("\nDone.")

if __name__ == '__main__':
    main()
