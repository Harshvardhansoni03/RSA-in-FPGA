// top.v
`timescale 1ns/1ps
module top (
    input  wire clk,    // board clock (100MHz on Nexys-4)
    input  wire rst,    // active-high reset (tie to a pushbutton)
    input  wire btnl,   // BTNL (P17) -> show plaintext (m)
    input  wire btnc,   // BTNC (N17) -> show ciphertext (c)
    input  wire btnr,   // BTNR (M17) -> show decrypted (m_dec)
    input  wire sw0,    // select upper/lower half
    // display pins
    output wire [7:0] an,
    output wire [6:0] seg
);

wire [63:0] m;
wire [63:0] c;
wire [63:0] m_dec;

// instantiate ROM (generated by your Python script)
wifi_key_rom rom_inst (
    .m_out(m)
);

// === Placeholder encryption/decryption (replace with real RSA wiring) ===
// simple placeholders so the design is functional for testing
assign c     = m + 64'h0000000000000001; // placeholder "encryption"
assign m_dec = m; // placeholder "decryption" (no-op)

// display selection logic (priority: btnl > btnc > btnr as written)
reg [63:0] display_val;
always @(*) begin
    // If multiple buttons pressed, priority given in order below:
    if (btnl)        display_val = m;       // BTNL -> plaintext
    else if (btnc)   display_val = c;       // BTNC -> ciphertext
    else if (btnr)   display_val = m_dec;   // BTNR -> decrypted
    else             display_val = m;       // default: plaintext
end

// instantiate display driver
display_driver disp (
    .clk(clk),
    .rst(rst),
    .value_in(display_val),
    .half_sel(sw0),
    .an(an),
    .seg(seg)
);

endmodule
